diff --git a/usb.c b/usb.c
index eb489df..eb45c30 100644
--- a/usb.c
+++ b/usb.c
@@ -166,16 +166,37 @@ static u32
 rtw89_usb_ops_check_and_reclaim_tx_resource(struct rtw89_dev *rtwdev,
 					    u8 txch)
 {
+	struct rtw89_usb *rtwusb = rtw89_usb_priv(rtwdev);
+	int inflight;
+
+	/* Firmware command channel doesn't use this tracking */
 	if (txch == RTW89_TXCH_CH12)
 		return 1;
 
-	return 42; /* TODO some kind of calculation? */
+	inflight = atomic_read(&rtwusb->tx_inflight[txch]);
+
+	/* DEBUG: Invariant checks */
+	if (unlikely(inflight < 0))
+		rtw89_warn(rtwdev, "TX flow ctrl: inflight UNDERFLOW ch=%d val=%d\n",
+			   txch, inflight);
+	if (unlikely(inflight > RTW89_USB_MAX_TX_URBS_PER_CH))
+		rtw89_warn(rtwdev, "TX flow ctrl: inflight OVERFLOW ch=%d val=%d\n",
+			   txch, inflight);
+
+	if (inflight >= RTW89_USB_MAX_TX_URBS_PER_CH) {
+		rtw89_info(rtwdev, "TX flow ctrl: BACKPRESSURE ch=%d inflight=%d\n",
+			   txch, inflight);
+		return 0;
+	}
+
+	return RTW89_USB_MAX_TX_URBS_PER_CH - inflight;
 }
 
 static void rtw89_usb_write_port_complete(struct urb *urb)
 {
 	struct rtw89_usb_tx_ctrl_block *txcb = urb->context;
 	struct rtw89_dev *rtwdev = txcb->rtwdev;
+	struct rtw89_usb *rtwusb = rtw89_usb_priv(rtwdev);
 	struct ieee80211_tx_info *info;
 	struct rtw89_txwd_body *txdesc;
 	struct sk_buff *skb;
@@ -234,6 +255,16 @@ static void rtw89_usb_write_port_complete(struct urb *urb)
 		break;
 	}
 
+	/* Skip tracking for firmware command channel (handled specially) */
+	if (txcb->txch != RTW89_TXCH_CH12) {
+		/* DEBUG: Check for underflow before decrement */
+		if (unlikely(atomic_read(&rtwusb->tx_inflight[txcb->txch]) <= 0))
+			rtw89_warn(rtwdev, "TX flow ctrl: decrement when inflight=%d ch=%d urb_status=%d\n",
+				   atomic_read(&rtwusb->tx_inflight[txcb->txch]),
+				   txcb->txch, urb->status);
+
+		atomic_dec(&rtwusb->tx_inflight[txcb->txch]);
+	}
 	kfree(txcb);
 }
 
@@ -321,6 +352,10 @@ static void rtw89_usb_ops_tx_kick_off(struct rtw89_dev *rtwdev, u8 txch)
 			skb_dequeue(&txcb->tx_ack_queue);
 			kfree(txcb);
 			rtw89_usb_tx_free_skb(rtwdev, txch, skb);
+		} else {
+			/* Skip tracking for firmware command channel */
+			if (txch != RTW89_TXCH_CH12)
+				atomic_inc(&rtwusb->tx_inflight[txch]);
 		}
 	}
 }
@@ -694,8 +729,10 @@ static void rtw89_usb_init_tx(struct rtw89_dev *rtwdev)
 	struct rtw89_usb *rtwusb = rtw89_usb_priv(rtwdev);
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(rtwusb->tx_queue); i++)
+	for (i = 0; i < ARRAY_SIZE(rtwusb->tx_queue); i++) {
 		skb_queue_head_init(&rtwusb->tx_queue[i]);
+		atomic_set(&rtwusb->tx_inflight[i], 0);
+	}
 }
 
 static void rtw89_usb_deinit_tx(struct rtw89_dev *rtwdev)
diff --git a/usb.h b/usb.h
index 9f554b5..bdef02c 100644
--- a/usb.h
+++ b/usb.h
@@ -21,6 +21,9 @@
 #define RTW89_MAX_BULKIN_NUM		2
 #define RTW89_MAX_BULKOUT_NUM		7
 
+/* TX flow control: max in-flight URBs per channel */
+#define RTW89_USB_MAX_TX_URBS_PER_CH	4  /* TEMP: testing backpressure */
+
 struct rtw89_usb_info {
 	u32 usb_host_request_2;
 	u32 usb_wlan0_1;
@@ -67,6 +70,9 @@ struct rtw89_usb {
 	struct usb_anchor tx_submitted;
 
 	struct sk_buff_head tx_queue[RTW89_TXCH_NUM];
+
+	/* TX flow control: track in-flight URBs per channel */
+	atomic_t tx_inflight[RTW89_TXCH_NUM];
 };
 
 static inline struct rtw89_usb *rtw89_usb_priv(struct rtw89_dev *rtwdev)
